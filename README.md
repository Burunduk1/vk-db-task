# Задание

[Исходная формулировка](statement.txt)

# Использование

* `make mainTest && ./mainTest` $-$ проверка корректности

* `make main && ./main` $-$ вычисление параметров оптимального решения

* `commonElements.cpp :: commonElements()` $-$ собственно решение

# Общая идея решения f(a, b)

**Пусть $|a| > |b|$**

1. Строим структуру данных $D$ от $b$.

2. Перебираем элементы $x \in b$, обращаемся к $D$ с запросом _"есть ли там $x$"_?

3. Поскольку по условию все элементы $a$ различны, ответ $-$ число результатов true.

# Оценка снизу

Поскольку 

* не предполагается, что от векторов можно заранее сделать какой-либо предподсчёт,
* содержимое $a$ и $b$ $-$ различные элементы, 
* у нас нет никаких данных о природе чисел в этих векторах,
 
решения лучше $O(|a|+|b|)$ нет.

# Выбор структуры данных $D$ 

Есть несколько хорошо известных вариантов. Для каждого указаны требуемая дополнительная память, время построения, 
время обработки запроса в зависимости от $n = |b|$.

| Структура      |  Память |  Построение   | Запрос      |
|----------------|--------:|--------------:|------------:|
| Массив/список  | (нет)   | (нет)         | $O(n)$      |
| `sorted set`   | $O(n)$  | $O(n \log n)$ | $O(\log n)$ |
| `sorted array` | $O(n)$  | $O(n \log n)$ | $O(\log n)$ |
| `hash table`   | $O(n)$  | $O(n)$        | $O(1)$      |

Решение (1) выделяется тем, что не требуется строить дополнительных структур данных, вид, в котором, 
нам выдали $b$ подходит без изменений.

Скорее всего (3) по всем параметрам лучше (2).

Решение (4) кажется оптимальным по асимптотике, но проигрывает (1) и (3) на маленьких $|b|$.

# Оптимальное по времени решение

Реализуем (1), (2), (3).
Эмпирическим путём вычисляем константы $C_1$, $C_2$, минимизирующие время кода:

```
if (n < C_1)      run (1) # array
else if (n < C_2) run (2) # sorted array
else              run (3) # hash table
```

Чтобы на малых $|a|+|b|$ на время работы не оказывало существенное влияние перевыделение памяти под $D$,
внутри $f$ переиспользуем структуры $D2$ и $D3$.

```
f(a, b) # |a| > |b|
	static sortedArray D2
	static hashTable D3
	n = |b|
	if (n < C1)      solution1(a, b)              # array
	else if (n < C2) D2.build(b) solution2(D2, a) # sorted array
	else             D3.build(b) solution3(D3, a) # hash table
```

# Альтернативные решения, улучшения

* Если требуется оптимальное по памяти решение, нужно всегда использовать (1).

* Константы $C_1$, $C_2$ зависят от целевой архитектуры. В текущей версии они подогнаны под мой домашний ноут.
Можно сделать их получение автоматическим процессом, запускающимся перед сборкой при развёртывании.

# Тестирование

* Несколько ручных тестов.

* Стресс-тестирование на случайных тестах (равномерное распределение).

* Вычисление времени работы на случайных тестах для $|a| \in \{10^6, 10^3, 10\}, |b| \in [1,|a|]$
