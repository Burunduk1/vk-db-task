# Задание

[Исходная формулировка](statement.txt)

# Использование

* `make mainTest && ./mainTest` &minus; проверка корректности

* `make main && ./main` &minus; вычисление параметров оптимального решения

* [commonElements.cpp](commonElements.cpp) :: `commonElements()` &minus; собственно решение

# Общая идея решения f(a, b)

**Пусть $|a| > |b|$**

1. Строим структуру данных $D$ от $b$.

2. Перебираем элементы $x \in b$, обращаемся к $D$ с запросом _"есть ли там $x$"_?

3. Поскольку по условию все элементы $a$ различны, ответ &minus; число результатов true.

# Оценка снизу

Поскольку 

* не предполагается, что от векторов можно заранее сделать какой-либо предподсчёт,
* содержимое $a$ и $b$ &minus; различные элементы, 
* у нас нет никаких данных о природе чисел в этих векторах,
 
решения лучше $O(|a|+|b|)$ нет.

# Выбор структуры данных $D$ 

Есть несколько хорошо известных вариантов. Для каждого указаны требуемая дополнительная память, время построения, 
время обработки запроса в зависимости от $n = |b|$.

| Структура      |  Память |  Построение   | Запрос      |
|----------------|--------:|--------------:|------------:|
| `array/list`   | (нет)   | (нет)         | $O(n)$      |
| `sorted set`   | $O(n)$  | $O(n \log n)$ | $O(\log n)$ |
| `sorted array` | $O(n)$  | $O(n \log n)$ | $O(\log n)$ |
| `hash table`   | $O(n)$  | $O(n)$        | $O(1)$      |

Решение (1) выделяется среди перечисленных тем, что не требуется строить дополнительных структур данных.
Вид, в котором, нам выдали $b$ подходит без изменений.

Решение (4) кажется оптимальным по асимптотике, но проигрывает (1), (2), (3) для маленьких $|b|$.

Более подробные результаты можно посмотреть в [выводе тестирующей программы](experimentResult.txt).

# Оптимальное по времени решение

Реализуем (1), (4)
Эмпирическим путём вычисляем константу $C = 111$, минимизирующую время кода:

```
if (n < C)  run (1) # array
else        run (4) # hash table
```

Чтобы на малых $|a|+|b|$ на время работы не оказывало существенное влияние перевыделение памяти под $D$,
внутри `f(a, b)` переиспользуем структуру, построенную при предыдущем вызове функции.

```
f(a, b) # |a| > |b|
	static hashTable D
	n = |b|
	if (n < C) solutionLinear(a, b)               # array
	else       D.build(b) solutionHashTable(D, a) # hash table
```

# Альтернативные решения, улучшения

* Если требуется оптимальное по памяти решение, нужно всегда использовать (1) array.

* Константа $C$ зависит от целевой архитектуры. 
В текущей версии она подогнана под мой домашний ноут.
В общем случае, возможно, также понадобится для некоторого диапазона n запускать решение (2) sortedArray.
Можно сделать получение всех этих данных автоматическим процессом, запускающимся на целевой архитектуре перед компиляцией основного кода.

# Тестирование

При тестировании для упрощения процесса используются и тесты с одинаковыми числами. 
Предполагаемое поведение программы: вернуть количество элементов $a$, содержащихся в $b$.
В большинстве тестов есть ограничение $a_i, b_i \in [1..x]$, числа генерируются равномерным распределением.

* Несколько ручных тестов.

* Стресс-тестирование на случайных маленьких тестах.
	* $|a|, |b| \in [1..6]$, $x = 10$
	* $|a|, |b| \in [10..20]$, $x = 10$
	* $|a|, |b| \in [10..20]$, $x = 100$
	* $|a|, |b| \in [10..20]$, $x = 10^9$
	* $|a|, |b| \in [1..100]$, $x = 100$

* Вычисление времени работы на случайных тестах для 
	* |a| = 2|b|, |b| = 1,2,...,13
	* |a| = 2|b|, |b| = 2^0,2^1,...,2^{12}
	* |a| = 10^4, |b| = 2^0,2^1,...,2^{12}
